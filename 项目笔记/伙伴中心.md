# 大批量数据插入数据库

1. 使用可视化界面，
2. 写程序，for 循环，建议分批，不要一把梭哈（可以用接口来控制）**要保证可控、幂等，注意线上环境和测试环境是有区别的**
3. 执行sql语句，适用与小数据量

## 编写程序，如何缩短任务时间

插入数据任务时间=建立和释放数据库链接+插入耗时

1.减少建立和释放数据库链接时间，使用批量插入技术。

2.插入耗时通过并发执行来减少

并发执行时，需要判断任务类

```base
// CPU 密集型：分配的核心线程数 = CPU - 1
// IO 密集型：分配的核心线程数可以大于 CPU 核数
```

在大量数据的背景下，存在几个问题：

1.数据库查询慢？（使用缓存，读写更快）

2.但第一次使用还是会去读取数据库，速度还是慢（预加载缓冲，定期更新缓冲。即定时任务）

3.那么等到项目上线，部署多个服务器。多个服务器都要执行任务吗?如何实现只需要一台服务器执行？（分布式锁！）

# 缓存

常见实现：

- Redis（分布式缓存）
- memcached（分布式）
- Etcd（云原生架构的一个分布式存储，**存储配置**，扩容能力）

---

- ehcache（单机）
- 本地缓存（Java 内存 Map）
- Caffeine（Java 内存缓存，高性能）
- Google Guava



## Redis

推荐使用redistemplate



常见的缓存技术选型：

1. 如果你用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便
2. 如果你用的不是 SPring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool
3. 如果你的项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池

---

- 如果你的项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐用 redisson



##设计缓冲key要点

1. redis内存有限，**存储的key一定要设置过期时间**
2. key值设计，使用项目名。systemId:moduleId:func:options（不要和别人冲突）



### 缓存预热

问题：第一个用户访问还是很慢（加入第一个老板），也能一定程度上保护数据库

缓存预热的优点：

1. 解决上面的问题，可以让用户始终访问很快

缺点：

1. 增加开发成本（你要额外的开发、设计）
2. 预热的时机和时间错了，则缓存的数据不对或者太老
3. 需要占用额外空间



#### 怎么缓存预热？

1. 定时任务
2. 模拟触发（手动触发）



#### 怎么实现缓存预热

用定时任务，每天刷新所有用户的推荐列表

注意点：

1. 缓存预热的意义（新增少、总用户多）
2. 缓存的空间不能太大，要预留给其他缓存空间
3. 缓存数据的周期（此处每天一次）

> 分析优缺点的时候，要打开思路，从整个项目从 0 到 1 的链路上去分析

# 定时任务

## 实现类型

1. **Spring Scheduler（spring boot 默认整合了）** 
2. Quartz（独立于 Spring 存在的定时任务框架）
3. XXL-Job 之类的分布式任务调度平台（界面 + sdk



## Spring Scheduler实现

第一种方式：

1. 主类开启 @EnableScheduling
2. 给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率



不要去背 cron 表达式！！！！！

- https://cron.qqe2.com/
- https://www.matools.com/crontab/





# 分布式锁

那么定时任务就引入了一个问题，项目上线后，面对多个服务器，如何实现对定时任务的控制？

## 为什么需要控制定时任务？

1.控制资源，避免浪费服务器资源

2.避免数据异常，例如脏读

所以**要控制定时任务在同一时间只有 1 个服务器能执行。**

## 如何实现？

1.分离定时任务和主程序，将定时任务只部署到一台服务器上。成本太大？（为什么成本太大？

2.进行条件判断，对执行任务服务器相关网络配置进行判断。但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本低，但是有可能服务器动态部署， IP 可能是不固定的。

3.动态配置，配置是可以轻松的、很方便地更新的（**代码无需重启**），但是只有 ip 符合配置的服务器才真实执行业务逻辑。

- 数据库

- Redis
- 配置中心（Nacos、Apollo、Spring Cloud Config）

问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改

上述**单机就会存在单点故障。**

-----------

4.分布式锁，只有抢到锁的服务器才能执行业务逻辑。坏处：增加成本；好处：不用手动配置，多少个服务器都一样。

## 本地线程锁

有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。

Java 实现锁：synchronized 关键字、并发包的类

问题：只对单个 JVM 有效



## 分布式锁

为啥需要分布式锁？

1. 有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。
2. 单个锁只对单个 JVM /服务器有效

### 机制

怎么保证同一时间只有 1 个服务器能抢到锁？

**核心思想** 就是：先来先到，先来先将标识改为自己的。后来的人等先来的人执行方法结束，把标识清空，其他的人继续抢锁。



## 设计注意事项

1. key/锁要加上过期时间

2. 锁一定要注销

3. 如果方法未执行完成，锁过期了，一定要有处理机制。

   问题：1. 连锁效应：释放掉别人的锁

   2. 这样还是会存在多个方法同时执行的情况

      解决方案：续期

   ----

   

4. 释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁。

5. 5.Redis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？红锁

## 实现方式

Redisson实现

Zookeeper 实现（不推荐）

## redis中的看门狗机制

是什么：redisson 中提供的续期机制



开一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。



原理：

1. 监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）
2. 如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期



https://blog.csdn.net/qq_26222859/article/details/79645203

# 查询语句

可以使用mysql中的Json类型。



session登陆和token登陆



qps怎么测



quartz和schedule来执行定时任务



怎么样来添加数据库数据



redis分布式登陆



添加相关库后，首先使用test来测试相关功能



用的最多list，map，set



redis集群，使用红锁



spring的beanuitl和apache的benutil有什么不同？

spring中好像有个小小坑？